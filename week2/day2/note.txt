Module 36 ‚Äì Error Handling & Exceptions (C++ Perspective)
1Ô∏è‚É£ Error vs Exception (Very Important Concept)
üîπ What is an Error?

Usually caused by programmer mistake

Logical mistake

Invalid algorithm

Wrong assumption

Examples:

Popping from empty stack

Accessing array out of bounds

Wrong condition in loop

üëâ These are bugs.

üîπ What is an Exception?

Unexpected

Rare

Often outside programmer‚Äôs full control

May crash the system

May be caused by:

Memory failure

Divide by zero

File not found

Network failure

Hardware interrupt

Key Difference
Error	Exception
Programmer mistake	Unexpected situation
Frequent	Infrequent
Logical issue	Runtime abnormal event
2Ô∏è‚É£ Causes of Exceptions (From Transcript ‚Äì C++ View)

The transcript mentioned multiple causes. Let‚Äôs explain in C++ context:

üîπ (1) Unexpected System State

Memory full

Disk full

Stack overflow

Heap exhausted

Example
#include <iostream>
using namespace std;

int main() {
    try {
        int* ptr = new int[1000000000000]; // Huge allocation
    }
    catch (bad_alloc& e) {
        cout << "Memory allocation failed!\n";
    }
}

‚úî bad_alloc is thrown automatically by C++ when memory fails.

üîπ (2) External Events

CTRL + C

OS signals

Network socket failure

In C++ we normally don‚Äôt handle raw signals directly for logic.
We use structured exception handling instead.

üîπ (3) Logical Errors

Example:

Pop from empty stack

Divide by zero

#include <iostream>
using namespace std;

int divide(int a, int b) {
    if (b == 0)
        throw runtime_error("Divide by zero!");
    return a / b;
}

int main() {
    try {
        cout << divide(10, 0);
    }
    catch (exception& e) {
        cout << e.what();
    }
}
üîπ (4) Resource Errors

Memory leak

File not opened

File read/write failure

#include <fstream>
#include <iostream>
using namespace std;

int main() {
    try {
        ifstream file("abc.txt");

        if (!file)
            throw runtime_error("File not found!");
    }
    catch (exception& e) {
        cout << e.what();
    }
}
üîπ (5) Runtime Errors

Overflow

Underflow

Out of range

Invalid operations

#include <vector>
#include <iostream>
using namespace std;

int main() {
    try {
        vector<int> v = {1,2,3};
        cout << v.at(10); // Throws out_of_range
    }
    catch (exception& e) {
        cout << e.what();
    }
}
3Ô∏è‚É£ Normal Flow vs Exception Flow

Transcript says:

In C, both flows are mixed.
In C++, they are separated.

‚úî In C++:

Normal code:

int result = a + b;

Exception flow:

try {
    riskyOperation();
}
catch (...) {
    handleError();
}

üî• C++ separates:

Normal logic

Error handling logic

This makes code clean.

4Ô∏è‚É£ Types of Exceptions
üîπ 1) Asynchronous Exception

No relation to current execution

External interrupt

OS signal

Example:

Hardware interrupt

CTRL+C

üîπ 2) Synchronous Exception

Happens during execution

Caused by program

Planned to be handled

Example:

throw runtime_error("Error happened");

Most C++ exceptions are synchronous.

5Ô∏è‚É£ 5 Stages of Exception Handling (Very Important)

Transcript clearly mentions 5 stages.

Let‚Äôs explain properly.

üîπ Stage 1: Incidence (Error Occurs)

Something goes wrong.

if (b == 0)
üîπ Stage 2: Create Exception Object
throw runtime_error("Divide by zero");

Here:

Object of type runtime_error is created.

üîπ Stage 3: Detection
catch(runtime_error& e)

System detects thrown object.

üîπ Stage 4: Handling
cout << e.what();

We handle it.

üîπ Stage 5: Recovery or Abort

Option 1 ‚Äì Recover:

cout << "Using default value instead.";

Option 2 ‚Äì Abort:

exit(1);
6Ô∏è‚É£ Simple Flow Example (From Transcript Concept)
Function throws ‚Üí main handles
#include <iostream>
using namespace std;

int f() {
    bool error = true;

    if (error) {
        throw -1;   // Stage 2
    }

    return 0;
}

int main() {
    try {
        f();   // Stage 1
    }
    catch (int x) {  // Stage 3
        cout << "Error occurred! Code: " << x << endl;  // Stage 4
    }

    cout << "Program continues\n";  // Stage 5
}
7Ô∏è‚É£ Why C++ Exception Handling is Better

Transcript mentions C problems, but we‚Äôll convert that into C++ advantages.

‚úî Advantages in C++:

Automatic destructor calls (RAII)

Clean separation of logic

No need for global variables

No need for goto

Structured mechanism

Type-safe

8Ô∏è‚É£ RAII (Very Important C++ Feature)

Destructor is automatically called during exception.

#include <iostream>
using namespace std;

class Test {
public:
    Test() { cout << "Constructor\n"; }
    ~Test() { cout << "Destructor\n"; }
};

int main() {
    try {
        Test t;
        throw runtime_error("Error!");
    }
    catch (...) {
        cout << "Caught exception\n";
    }
}
Output:
Constructor
Destructor
Caught exception

üî• Destructor runs automatically.
This is a HUGE improvement over C.

9Ô∏è‚É£ Practice Program (Complete Concept)
#include <iostream>
#include <stdexcept>
using namespace std;

class BankAccount {
    double balance;

public:
    BankAccount(double b) : balance(b) {}

    void withdraw(double amount) {
        if (amount > balance)
            throw runtime_error("Insufficient balance!");

        balance -= amount;
    }

    void show() {
        cout << "Balance: " << balance << endl;
    }
};

int main() {
    try {
        BankAccount acc(1000);

        acc.withdraw(500);
        acc.show();

        acc.withdraw(600);  // Exception here

        acc.show();
    }
    catch (exception& e) {
        cout << "Exception: " << e.what() << endl;
    }

    cout << "Program continues safely.\n";
}
üîü Summary (Following Transcript)
‚úî We Learned:

Difference between error and exception

Causes of exceptions

Normal vs exception flow

Types: synchronous & asynchronous

5 stages of handling

Separation of logic in C++

RAII and destructor safety

Structured handling using:

try

throw

catch

üéØ Final Concept Map
Error Happens
     ‚Üì
throw object
     ‚Üì
catch block detects
     ‚Üì
handle error
     ‚Üì
recover or terminate

Why C++ Exception Mechanism is Special

According to transcript, C++ provides a single structured mechanism that handles:

Synchronous errors

Asynchronous errors (conceptually)

Logical errors

Runtime errors

Resource errors

All under ONE mechanism:

üëâ try ‚Äì throw ‚Äì catch
2Ô∏è‚É£ Desirable Characteristics of C++ Exceptions

The lecture lists important features. Let‚Äôs explain each.

üîπ (1) Separation of Normal Flow and Error Flow

In C++:

try {
    // Normal logic
}
catch (...) {
    // Error handling logic
}

‚úî Normal logic is separate
‚úî Error logic is separate
‚úî Clean code

üîπ (2) Language Mechanism (Not Just Library)

Exceptions are part of the C++ language itself.

Compiler understands:

try

catch

throw

This allows:

Stack unwinding

Destructor calls

Type matching

üîπ (3) Automatic Destruction of Objects (VERY IMPORTANT)

If exception occurs:

Stack frame is removed

Local automatic objects are destroyed

Destructor is called automatically

This is called:

üëâ Stack Unwinding
üî• Practice Example (Stack Unwinding)
#include <iostream>
using namespace std;

class Test {
public:
    Test() { cout << "Constructor\n"; }
    ~Test() { cout << "Destructor\n"; }
};

void func() {
    Test t;
    throw runtime_error("Error occurred!");
}

int main() {
    try {
        func();
    }
    catch (...) {
        cout << "Exception caught\n";
    }
}
Output:
Constructor
Destructor
Exception caught

‚úî Destructor executed automatically
‚úî Even though function didn‚Äôt end normally

üîπ (4) Can Exit Deep Nesting

If:

main ‚Üí f ‚Üí g ‚Üí h

If error happens in h,
Exception can travel back to main automatically.

No goto needed.

üîπ (5) Multiple Exceptions Handled by Single Handler

You can write:

catch (...) {
    // Catch any type
}
3Ô∏è‚É£ Basic Mechanism: try ‚Äì throw ‚Äì catch
üîπ Structure
try {
    // Code that may throw
}
catch(Type e) {
    // Handler
}
üîπ Throwing Exception
throw runtime_error("Problem!");
üîπ Complete Example
#include <iostream>
using namespace std;

void g() {
    cout << "g started\n";
    throw runtime_error("Error in g");
    cout << "g ended\n";  // never executed
}

int main() {
    try {
        g();
        cout << "Returned from g\n";
    }
    catch (exception& e) {
        cout << "Caught: " << e.what() << endl;
    }
}
4Ô∏è‚É£ What Happens Internally (Very Important)

When throw happens:

Exception object is created

Stack unwinding begins

Local objects are destroyed

Control moves to matching catch

Handler executes

Normal flow resumes

5Ô∏è‚É£ Exception Object

You can throw:

int

double

string

Your class

Standard library exception

üîπ Custom Exception Example
#include <iostream>
#include <exception>
using namespace std;

class MyException : public exception {
public:
    const char* what() const noexcept override {
        return "Custom exception!";
    }
};

int main() {
    try {
        throw MyException();
    }
    catch (exception& e) {
        cout << e.what();
    }
}
6Ô∏è‚É£ Multiple Catch Clauses

Matching happens in order.

üî• Example (Important Practice)
#include <iostream>
using namespace std;

void test(int x) {
    if (x == 1) throw 10;
    if (x == 2) throw 3.14;
    if (x == 3) throw runtime_error("Error");
}

int main() {
    try {
        test(2);
    }
    catch (int i) {
        cout << "Integer caught\n";
    }
    catch (double d) {
        cout << "Double caught\n";
    }
    catch (...) {
        cout << "Unknown exception\n";
    }
}
7Ô∏è‚É£ Important Matching Rules (From Transcript)

‚úî Exact match preferred
‚úî No implicit conversions
‚úî Upcasting allowed
‚úî Order matters

üîπ Derived vs Base Example
class Base {};
class Derived : public Base {};

int main() {
    try {
        throw Derived();
    }
    catch (Derived d) {
        cout << "Derived caught\n";
    }
    catch (Base b) {
        cout << "Base caught\n";
    }
}

‚ö† If you reverse order:

catch (Base b)
catch (Derived d)

Derived will never execute.

üëâ Always put derived first.

8Ô∏è‚É£ Catch-All Clause

Must be last.

catch (...) {
    cout << "Catch all\n";
}

If not last ‚Üí hides others.

9Ô∏è‚É£ Exception Propagation

If a function does not handle exception,
It automatically propagates to caller.

üî• Deep Call Example (Very Important)
#include <iostream>
using namespace std;

void h() {
    throw runtime_error("Error in h");
}

void g() {
    h();  // not handling
}

void f() {
    try {
        g();
    }
    catch (exception& e) {
        cout << "Handled in f: " << e.what() << endl;
    }
}

int main() {
    f();
}

Exception travels:
h ‚Üí g ‚Üí f

üîü Rethrow (Very Important Concept)

Two types:

üîπ 1) Simple Rethrow
catch (...) {
    throw;   // same object forwarded
}

No new object created.

üîπ 2) Rethrow with Object
catch (exception& e) {
    throw e;  // copy created
}

Copy constructor required.

1Ô∏è‚É£1Ô∏è‚É£ Function Try Block

Whole function body inside try.

int main() try {
    throw runtime_error("Error");
}
catch (...) {
    cout << "Handled\n";
}

No extra braces needed.

1Ô∏è‚É£2Ô∏è‚É£ If No Handler Found

If exception reaches main
and no catch matches:

üëâ terminate() is called
üëâ Program ends

1Ô∏è‚É£3Ô∏è‚É£ Standard Exception Hierarchy

Base class:

std::exception

Common Derived Classes:

runtime_error

logic_error

bad_alloc

bad_cast

out_of_range

invalid_argument

üî• Example: bad_alloc
#include <iostream>
using namespace std;

int main() {
    try {
        int* ptr = new int[1000000000000];
    }
    catch (bad_alloc& e) {
        cout << "Memory failed\n";
    }
}
1Ô∏è‚É£4Ô∏è‚É£ Exception Object Creation

Exception objects:

Created on free store

Automatically destroyed after handling

Must have:

Destructor

Copy constructor (for rethrow)

1Ô∏è‚É£5Ô∏è‚É£ Advantages of C++ Exceptions

‚úî Destructor safe
‚úî Clean code
‚úî Scalable
‚úî Language supported
‚úî Type-safe
‚úî Supports multiple handlers
‚úî Supports rethrow
‚úî Stack unwinding

üî∂ Final Summary (Following Transcript Exactly)

C++ Exception Mechanism Provides:

try block

throw statement

catch handlers

Stack unwinding

Automatic destructor calls

Propagation through call stack

Multiple handlers

Catch-all

Rethrow

Standard exception hierarchy

terminate() if unhandled

üéØ Complete Mental Flow
try block
    ‚Üì
function call
    ‚Üì
throw happens
    ‚Üì
stack unwinding
    ‚Üì
matching catch
    ‚Üì
handler executes
    ‚Üì
normal flow resumes


aslo add this as resource into end of note
https://www.youtube.com/watch?v=S322GolfN90&list=PLqu1LEUz3ju04dXn0JOgKYPHHnV2at-lG&index=46
https://www.youtube.com/watch?v=-kiafRegO1E&list=PLqu1LEUz3ju04dXn0JOgKYPHHnV2at-lG&index=47

https://www.geeksforgeeks.org/cpp/exception-handling-c/


https://www.geeksforgeeks.org/cpp/exception-handling-using-classes-in-cpp/
https://www.geeksforgeeks.org/cpp/stack-unwinding-in-c/

https://www.geeksforgeeks.org/cpp/user-defined-custom-exception-with-class-in-c/    