constexpr (Constant Expression)
ğŸ”¹ What is constexpr?

constexpr is used to tell the compiler:

"This expression MUST be evaluated at compile time."

It improves:

âœ… Performance

âœ… Safety

âœ… Compile-time guarantees

ğŸ”¹ Difference: const vs constexpr
const	constexpr
Value cannot change	Must be evaluated at compile time
Can be runtime constant	Must be compile-time constant
Focus = immutability	Focus = compile-time evaluation
ğŸ”¹ Example 1: Basic Usage
#include <iostream>
using namespace std;

constexpr int square(int x) {
    return x * x;
}

int main() {
    constexpr int val = square(5);  // Evaluated at compile time
    cout << val << endl;
}

ğŸ‘‰ square(5) is computed during compilation.

ğŸ”¹ Example 2: constexpr with User Defined Type
#include <iostream>
using namespace std;

struct Point {
    int x, y;

    constexpr Point(int a, int b) : x(a), y(b) {}
};

int main() {
    constexpr Point origin(0, 0);   // Constructed at compile time
    constexpr int value = origin.x;

    cout << value << endl;
}

âœ” C++11 allows constexpr constructors.

ğŸ”¹ Where constexpr is useful?

Array size

Switch case

Template parameters

Enum values

ğŸ”¹ Example: Switch Case (From Transcript Idea)
enum Flags { GOOD = 1, BAD = 2, EOF_FLAG = 4 };

constexpr int operator|(Flags a, Flags b) {
    return int(a) | int(b);
}

int main() {
    switch (BAD | EOF_FLAG) {
        case BAD | EOF_FLAG:
            cout << "Matched\n";
            break;
    }
}

Without constexpr, this would not compile in switch case.

2ï¸âƒ£ noexcept
ğŸ”¹ What is noexcept?

Used to declare:

"This function will NOT throw exceptions."

It is a compile-time feature.

ğŸ”¹ Basic Example
#include <iostream>
using namespace std;

void func() noexcept {
    cout << "Safe function\n";
}

If func() throws â†’ std::terminate() is called.

ğŸ”¹ Conditional noexcept (Important for Templates)

From transcript:

#include <iostream>
#include <vector>
using namespace std;

template<typename T>
void callFunc(T f, vector<int>& v) 
    noexcept(noexcept(f(v.at(0))))
{
    f(v.at(0));
}
Explanation:

noexcept(expr) checks at compile time whether expr can throw.

If true â†’ function becomes noexcept.

If false â†’ function is not noexcept.

âš¡ Very powerful in template programming.

ğŸ”¹ Why Important?

Improves STL performance

Move constructors should be noexcept

Destructors should not throw

3ï¸âƒ£ nullptr
ğŸ”¹ Problem Before C++11

NULL was basically 0.

This created confusion in function overloading.

ğŸ”¹ C++11 Solution: nullptr

nullptr is:

A keyword

Type: std::nullptr_t

Can convert to any pointer

Cannot convert to int

ğŸ”¹ Example 1
int* p = nullptr;

if (p == nullptr) {
    cout << "Null pointer\n";
}
ğŸ”¹ Function Overload Problem
#include <iostream>
using namespace std;

void func(int) {
    cout << "Integer version\n";
}

void func(int*) {
    cout << "Pointer version\n";
}

int main() {
    func(0);        // Calls int version
    func(nullptr);  // Calls pointer version
}

ğŸ”¥ nullptr solves overload ambiguity.

ğŸ”¹ Template Forwarding Problem (Advanced Concept)
void h(int*) {
    cout << "Pointer function\n";
}

template<typename F, typename P>
void logAndCall(F func, P param) {
    func(param);
}

int main() {
    logAndCall(h, nullptr);  // Works correctly
}

If you pass 0 â†’ template deduces int â†’ fails.
If you pass nullptr â†’ deduces correct pointer type.

4ï¸âƒ£ Inline Namespaces (Version Management)

Used for:

Library version control

ğŸ”¹ Why Needed?

Suppose a company releases:

Version 1

Version 2

They want:

Default â†’ New version

Optional â†’ Old version

ğŸ”¹ Example
#include <iostream>
using namespace std;

namespace Library {

    namespace v1 {
        void show() {
            cout << "Version 1\n";
        }
    }

    inline namespace v2 {
        void show() {
            cout << "Version 2\n";
        }
    }
}

int main() {
    Library::show();      // Calls v2 (default)
    Library::v1::show();  // Explicitly call old version
}

âœ” inline namespace makes version default automatically.

5ï¸âƒ£ User Defined Literals
ğŸ”¹ Problem

We can write:

10
3.14
"hello"

But cannot write:

10_km
3.5_kg

C++11 solves this.

ğŸ”¹ Syntax
return_type operator "" _suffix(parameters)

âš  Suffix must start with underscore _

ğŸ”¹ Example 1: Seconds Literal
#include <iostream>
using namespace std;

long double operator "" _sec(long double val) {
    return val;
}

int main() {
    auto time = 5.0_sec;
    cout << time << " seconds\n";
}
ğŸ”¹ Example 2: Kilogram Conversion
long double operator "" _kg(long double val) {
    return val * 1000;  // convert to grams
}

int main() {
    cout << 3.5_kg << " grams\n";
}
ğŸ”¹ Example 3: Complex Number
#include <iostream>
#include <complex>
using namespace std;

complex<double> operator "" _i(long double val) {
    return complex<double>(0, val);
}

int main() {
    complex<double> c = 3.0 + 4.0_i;
    cout << c << endl;
}
ğŸ”¹ Why Powerful?

Makes code readable

Creates literals for user-defined types

Used in STL (like "hello"s)

6ï¸âƒ£ Raw String Literals
ğŸ”¹ Problem

Normal string:

"Line1\nLine2"

\n becomes new line.

ğŸ”¹ Raw String Solution
R"(Line1\nLine2)"

Now \n is treated literally.

ğŸ”¹ Example
#include <iostream>
using namespace std;

int main() {
    string s = R"(This is a raw string.
No escape characters here.
\ n is printed as it is.)";

    cout << s;
}
ğŸ“Œ Summary of Module 48
Feature	Purpose
constexpr	Compile-time computation
noexcept	Guarantee no exception
nullptr	Safe null pointer
Inline Namespace	Library version control
User Defined Literals	Custom literals
Raw String	Disable escape characters
ğŸ¯ What You Should Practice

Write constexpr functions

Create your own _km, _min, _hr literal

Create versioned namespace

Practice function overloading with nullptr

Write template with conditional noexcept

(section wise divide into html and css note)

1ï¸âƒ£ First Understand the Real Problem

Without virtual function:

class Base {
public:
    void show() {
        cout << "Base\n";
    }
};

class Derived : public Base {
public:
    void show() {
        cout << "Derived\n";
    }
};

int main() {
    Base* ptr = new Derived();
    ptr->show();
}
What will print?

ğŸ‘‰ Base

Why?

Because function call depends on pointer type
Pointer type = Base*
So Base::show() is called.

This is called:

Compile Time Binding (Static Binding)

ğŸ”¹ 2ï¸âƒ£ Now Add Virtual
class Base {
public:
    virtual void show() {
        cout << "Base\n";
    }
};

Now output will be:

ğŸ‘‰ Derived

Why?

Because now function call depends on object type, not pointer type.

This is:

Runtime Polymorphism
Dynamic Binding

ğŸ”¹ 3ï¸âƒ£ HOW DOES THIS HAPPEN INTERNALLY?

Now comes the real magic.

Compiler secretly creates:

vTable (per class)

vPtr (per object)

ğŸ”¹ 4ï¸âƒ£ What Exactly Is vTable?

Think of vTable as:

ğŸ“¦ A box containing function addresses.

Example:

Base has 3 virtual functions:

function1()
function2()
function3()

Compiler makes something like:

Base vTable:

Index	Address
0	Base::function1
1	Base::function2
2	Base::function3
ğŸ”¹ 5ï¸âƒ£ What Is vPtr?

Now when object is created:

Base obj;

Memory looks like:

-------------------
| vPtr            | ----> points to Base vTable
-------------------
| data members    |
-------------------

âš  You cannot see vPtr in code.
Compiler adds it secretly.

ğŸ”¹ 6ï¸âƒ£ Now Letâ€™s Understand Your Big Example Slowly

You have:

Base
Derived1
Derived2

ğŸ”¹ Base vTable

Base has 3 virtual functions.

So Base vTable:

| 0 | Base::function1 |
| 1 | Base::function2 |
| 2 | Base::function3 |

ğŸ”¹ Derived1

Derived1 overrides only function1.

So Derived1 vTable becomes:

| 0 | Derived1::function1 |
| 1 | Base::function2 |
| 2 | Base::function3 |

Only first entry changed.

ğŸ”¹ Derived2

Derived2 overrides function2.

So Derived2 vTable becomes:

| 0 | Derived1::function1 |
| 1 | Derived2::function2 |
| 2 | Base::function3 |

See carefully:

function1 â†’ comes from Derived1
function2 â†’ comes from Derived2
function3 â†’ still Base

ğŸ”¹ 7ï¸âƒ£ Now Understand This Line Very Carefully
Base* ptr3 = new Derived2();

Important:

Pointer type = Base
Object type = Derived2

Now when object is created:

Memory:

-------------------
| vPtr            | ----> points to Derived2 vTable
-------------------
| Base part       |
| Derived1 part   |
| Derived2 part   |
-------------------

vPtr points to Derived2 table.

ğŸ”¹ 8ï¸âƒ£ When You Call
ptr3->function2();

What happens internally:

Step 1 â†’ compiler sees function is virtual
Step 2 â†’ go to object
Step 3 â†’ read vPtr
Step 4 â†’ go to Derived2 vTable
Step 5 â†’ call entry at index 1
Step 6 â†’ Derived2::function2() runs

Thatâ€™s it.

This is Runtime Polymorphism.

ğŸ”¹ 9ï¸âƒ£ Why vTable Is Needed?

Because at compile time, compiler only knows:

Base* ptr

It does NOT know:

Is object Base?
Is object Derived1?
Is object Derived2?

So decision is delayed until runtime.

ğŸ”¥ 10ï¸âƒ£ Very Important: Virtual Destructor

Now most important concept.

Look at this:

base *b = new derived();
delete b;

If destructor is NOT virtual:

Only base destructor runs.

Derived destructor does NOT run.

This is dangerous.

ğŸ”¹ Why Dangerous?

Imagine:

class derived {
    int* ptr;
public:
    derived() {
        ptr = new int[100];
    }
    ~derived() {
        delete[] ptr;
    }
};

If derived destructor does not run:

Memory is never freed.

ğŸ’¥ Memory leak.

ğŸ”¹ Why Destructor Must Be Virtual?

When destructor is virtual:

Compiler also puts destructor in vTable.

Now when:

delete b;

It checks vPtr â†’ goes to correct destructor â†’ calls:

Derived destructor

Base destructor

Correct order.

ğŸ”¥ Golden Rule (Very Important)

If class has ANY virtual function:

ğŸ‘‰ Always make destructor virtual.

Even if it is empty.

ğŸ”¹ 11ï¸âƒ£ Interview Important Points

âœ” vTable is created per class
âœ” vPtr is created per object
âœ” Only classes with virtual functions have vPtr
âœ” Dynamic binding happens using vPtr
âœ” Virtual destructor prevents memory leak
âœ” vTable mechanism is compiler implementation detail

ğŸ”¹ 12ï¸âƒ£ One More Deep Concept

If no virtual function:

Object memory:

| data |

If virtual function exists:

| vPtr | data |

So object size increases by pointer size (usually 8 bytes).

ğŸ”¥ Final Super Simple Summary

vTable = table of virtual functions
vPtr = pointer inside object pointing to vTable
Used for = runtime polymorphism
Destructor must be virtual = yes always