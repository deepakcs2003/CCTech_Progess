constexpr (Constant Expression)
ğŸ”¹ What is constexpr?

constexpr is used to tell the compiler:

"This expression MUST be evaluated at compile time."

It improves:

âœ… Performance

âœ… Safety

âœ… Compile-time guarantees

ğŸ”¹ Difference: const vs constexpr
const	constexpr
Value cannot change	Must be evaluated at compile time
Can be runtime constant	Must be compile-time constant
Focus = immutability	Focus = compile-time evaluation
ğŸ”¹ Example 1: Basic Usage
#include <iostream>
using namespace std;

constexpr int square(int x) {
    return x * x;
}

int main() {
    constexpr int val = square(5);  // Evaluated at compile time
    cout << val << endl;
}

ğŸ‘‰ square(5) is computed during compilation.

ğŸ”¹ Example 2: constexpr with User Defined Type
#include <iostream>
using namespace std;

struct Point {
    int x, y;

    constexpr Point(int a, int b) : x(a), y(b) {}
};

int main() {
    constexpr Point origin(0, 0);   // Constructed at compile time
    constexpr int value = origin.x;

    cout << value << endl;
}

âœ” C++11 allows constexpr constructors.

ğŸ”¹ Where constexpr is useful?

Array size

Switch case

Template parameters

Enum values

ğŸ”¹ Example: Switch Case (From Transcript Idea)
enum Flags { GOOD = 1, BAD = 2, EOF_FLAG = 4 };

constexpr int operator|(Flags a, Flags b) {
    return int(a) | int(b);
}

int main() {
    switch (BAD | EOF_FLAG) {
        case BAD | EOF_FLAG:
            cout << "Matched\n";
            break;
    }
}

Without constexpr, this would not compile in switch case.

2ï¸âƒ£ noexcept
ğŸ”¹ What is noexcept?

Used to declare:

"This function will NOT throw exceptions."

It is a compile-time feature.

ğŸ”¹ Basic Example
#include <iostream>
using namespace std;

void func() noexcept {
    cout << "Safe function\n";
}

If func() throws â†’ std::terminate() is called.

ğŸ”¹ Conditional noexcept (Important for Templates)

From transcript:

#include <iostream>
#include <vector>
using namespace std;

template<typename T>
void callFunc(T f, vector<int>& v) 
    noexcept(noexcept(f(v.at(0))))
{
    f(v.at(0));
}
Explanation:

noexcept(expr) checks at compile time whether expr can throw.

If true â†’ function becomes noexcept.

If false â†’ function is not noexcept.

âš¡ Very powerful in template programming.

ğŸ”¹ Why Important?

Improves STL performance

Move constructors should be noexcept

Destructors should not throw

3ï¸âƒ£ nullptr
ğŸ”¹ Problem Before C++11

NULL was basically 0.

This created confusion in function overloading.

ğŸ”¹ C++11 Solution: nullptr

nullptr is:

A keyword

Type: std::nullptr_t

Can convert to any pointer

Cannot convert to int

ğŸ”¹ Example 1
int* p = nullptr;

if (p == nullptr) {
    cout << "Null pointer\n";
}
ğŸ”¹ Function Overload Problem
#include <iostream>
using namespace std;

void func(int) {
    cout << "Integer version\n";
}

void func(int*) {
    cout << "Pointer version\n";
}

int main() {
    func(0);        // Calls int version
    func(nullptr);  // Calls pointer version
}

ğŸ”¥ nullptr solves overload ambiguity.

ğŸ”¹ Template Forwarding Problem (Advanced Concept)
void h(int*) {
    cout << "Pointer function\n";
}

template<typename F, typename P>
void logAndCall(F func, P param) {
    func(param);
}

int main() {
    logAndCall(h, nullptr);  // Works correctly
}

If you pass 0 â†’ template deduces int â†’ fails.
If you pass nullptr â†’ deduces correct pointer type.

4ï¸âƒ£ Inline Namespaces (Version Management)

Used for:

Library version control

ğŸ”¹ Why Needed?

Suppose a company releases:

Version 1

Version 2

They want:

Default â†’ New version

Optional â†’ Old version

ğŸ”¹ Example
#include <iostream>
using namespace std;

namespace Library {

    namespace v1 {
        void show() {
            cout << "Version 1\n";
        }
    }

    inline namespace v2 {
        void show() {
            cout << "Version 2\n";
        }
    }
}

int main() {
    Library::show();      // Calls v2 (default)
    Library::v1::show();  // Explicitly call old version
}

âœ” inline namespace makes version default automatically.

5ï¸âƒ£ User Defined Literals
ğŸ”¹ Problem

We can write:

10
3.14
"hello"

But cannot write:

10_km
3.5_kg

C++11 solves this.

ğŸ”¹ Syntax
return_type operator "" _suffix(parameters)

âš  Suffix must start with underscore _

ğŸ”¹ Example 1: Seconds Literal
#include <iostream>
using namespace std;

long double operator "" _sec(long double val) {
    return val;
}

int main() {
    auto time = 5.0_sec;
    cout << time << " seconds\n";
}
ğŸ”¹ Example 2: Kilogram Conversion
long double operator "" _kg(long double val) {
    return val * 1000;  // convert to grams
}

int main() {
    cout << 3.5_kg << " grams\n";
}
ğŸ”¹ Example 3: Complex Number
#include <iostream>
#include <complex>
using namespace std;

complex<double> operator "" _i(long double val) {
    return complex<double>(0, val);
}

int main() {
    complex<double> c = 3.0 + 4.0_i;
    cout << c << endl;
}
ğŸ”¹ Why Powerful?

Makes code readable

Creates literals for user-defined types

Used in STL (like "hello"s)

6ï¸âƒ£ Raw String Literals
ğŸ”¹ Problem

Normal string:

"Line1\nLine2"

\n becomes new line.

ğŸ”¹ Raw String Solution
R"(Line1\nLine2)"

Now \n is treated literally.

ğŸ”¹ Example
#include <iostream>
using namespace std;

int main() {
    string s = R"(This is a raw string.
No escape characters here.
\ n is printed as it is.)";

    cout << s;
}
ğŸ“Œ Summary of Module 48
Feature	Purpose
constexpr	Compile-time computation
noexcept	Guarantee no exception
nullptr	Safe null pointer
Inline Namespace	Library version control
User Defined Literals	Custom literals
Raw String	Disable escape characters
ğŸ¯ What You Should Practice

Write constexpr functions

Create your own _km, _min, _hr literal

Create versioned namespace

Practice function overloading with nullptr

Write template with conditional noexcept

(section wise divide into html and css note)

